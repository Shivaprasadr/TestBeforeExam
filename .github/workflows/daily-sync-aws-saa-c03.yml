name: Daily Sync - AWS SAA-C03 Questions

on:
  schedule:
    - cron: '0 6 * * *'  # Daily at 6:00 AM UTC
  workflow_dispatch:  # Allow manual triggering

env:
  # Source repository configuration (keep private)
  SOURCE_REPO_URL: ${{ secrets.AWS_SAA_C03_SOURCE_URL }}
  SOURCE_FILE_PATH: ${{ secrets.AWS_SAA_C03_SOURCE_FILE }}

jobs:
  sync-aws-questions:
    runs-on: ubuntu-latest
    permissions:
      contents: write
    
    steps:
    - name: Checkout repository
      uses: actions/checkout@v4
      with:
        token: ${{ secrets.GITHUB_TOKEN }}
        persist-credentials: true
        
    - name: Setup Node.js
      uses: actions/setup-node@v4
      with:
        node-version: '18'
        
    - name: Install dependencies (on-the-fly)
      run: |
        npm init -y
        npm install axios cheerio pdf-parse --no-save
        
    - name: Check for updates in source repository
      id: check_updates
      run: |
        # Get the latest commit hash from the source repository
        SOURCE_COMMIT=$(curl -s "https://api.github.com/repos/${{ env.SOURCE_REPO_NAME }}/commits/main" | jq -r '.sha')
        echo "source_commit=$SOURCE_COMMIT" >> $GITHUB_OUTPUT
        
        # Check if we have a record of the last processed commit
        LAST_PROCESSED=""
        if [ -f "sync-records/last-aws-sync.txt" ]; then
          LAST_PROCESSED=$(cat sync-records/last-aws-sync.txt)
        fi
        echo "last_processed=$LAST_PROCESSED" >> $GITHUB_OUTPUT
        
        # Determine if we need to update
        if [ "$SOURCE_COMMIT" != "$LAST_PROCESSED" ]; then
          echo "needs_update=true" >> $GITHUB_OUTPUT
          echo "üìÑ New changes detected in source repository"
        else
          echo "needs_update=false" >> $GITHUB_OUTPUT
          echo "‚úÖ No changes in source repository"
        fi
        
    - name: Clone source repository
      if: steps.check_updates.outputs.needs_update == 'true'
      run: |
        git clone ${{ env.SOURCE_REPO_URL }} temp-aws-repo
        
    - name: Process AWS questions (parse actual source)
      if: steps.check_updates.outputs.needs_update == 'true'
      run: |
        # Enhanced processor to parse AWS solution file with proper multiple choice extraction
        node -e "
        const fs = require('fs');
        const path = require('path');
        
        console.log('üîç Starting AWS SAA-C03 question processing...');
        
        // Ensure directories exist
        const saac03Dir = 'data/subjects/cloud-computing/aws/saa-c03';
        fs.mkdirSync(saac03Dir, { recursive: true });
        
        // Read the source solution file
        const sourceFile = 'temp-aws-repo/' + process.env.SOURCE_FILE_PATH;
        if (!fs.existsSync(sourceFile)) {
          console.error('‚ùå Source file not found:', sourceFile);
          process.exit(1);
        }
        
        const content = fs.readFileSync(sourceFile, 'utf8');
        console.log('üìÑ Source file loaded:', content.length, 'characters');
        
        // Split content by question separators (lines with dashes or question numbers)
        let questionBlocks = [];
        const lines = content.split('\n');
        let currentBlock = [];
        
        for (let i = 0; i < lines.length; i++) {
          const line = lines[i].trim();
          
          // Check if this is a new question start
          if (/^\d+\]\s/.test(line) && currentBlock.length > 0) {
            // Save previous block
            questionBlocks.push(currentBlock.join('\n'));
            currentBlock = [line];
          } else {
            currentBlock.push(line);
          }
        }
        
        // Add final block
        if (currentBlock.length > 0) {
          questionBlocks.push(currentBlock.join('\n'));
        }
        
        questionBlocks = questionBlocks.filter(block => block.trim() && /^\d+\]/.test(block.trim()));
        const questions = [];
        
        console.log('üìä Found', questionBlocks.length, 'question blocks');
        
        questionBlocks.forEach((block, index) => {
          const lines = block.split('\n').map(line => line.trim()).filter(line => line);
          if (lines.length === 0) return;
          
          // Find question start (number followed by ])
          let questionStartIndex = -1;
          let questionNumber = 0;
          let questionText = '';
          
          for (let i = 0; i < lines.length; i++) {
            const match = lines[i].match(/^(\d+)\]\s*(.+)/);
            if (match) {
              questionStartIndex = i;
              questionNumber = parseInt(match[1]);
              questionText = match[2];
              break;
            }
          }
          
          if (questionStartIndex === -1) return;
          
          // Extract question text (continue until we hit answer options or 'ans-')
          let fullQuestion = questionText;
          let i = questionStartIndex + 1;
          
          while (i < lines.length) {
            const line = lines[i];
            
            // Stop if we hit answer line or multiple choice options
            if (line.startsWith('ans-') || /^[A-D]\.\s/.test(line)) {
              break;
            }
            
            // Add question ending phrases
            if (line === 'Which solution meets these requirements?' ||
                line === 'What should the solutions architect do to meet these requirements?' ||
                line === 'Which solution will meet these requirements?' ||
                line.includes('Which combination of actions') ||
                line.includes('What should a solutions architect do')) {
              fullQuestion += ' ' + line;
              break;
            }
            
            // Add to question if it's substantial content
            if (line.length > 10 && !line.startsWith('Keywords:') && !line.startsWith('General line:')) {
              fullQuestion += ' ' + line;
            }
            i++;
          }
          
          // Look for answer line (ans-)
          let correctAnswer = null;
          let answerLetter = null;
          let explanation = '';
          
          for (let j = 0; j < lines.length; j++) {
            const line = lines[j];
            
            if (line.startsWith('ans-')) {
              const answerText = line.replace(/^ans-\s*/, '');
              
              // Check if answer starts with a letter (A., B., C., D.)
              const letterMatch = answerText.match(/^([A-D])\.\s*(.+)/);
              if (letterMatch) {
                answerLetter = letterMatch[1];
                correctAnswer = letterMatch[2];
              } else {
                correctAnswer = answerText;
              }
              
              // Collect explanation from subsequent lines
              for (let k = j + 1; k < lines.length; k++) {
                const explainLine = lines[k];
                if (explainLine && !explainLine.startsWith('---') && explainLine.length > 10) {
                  explanation += (explanation ? ' ' : '') + explainLine;
                }
              }
              break;
            }
          }
          
          // Extract multiple choice options if they exist
          const options = [];
          for (let j = 0; j < lines.length; j++) {
            const line = lines[j];
            const optionMatch = line.match(/^([A-D])\.\s*(.+)/);
            if (optionMatch && !line.startsWith('ans-')) {
              options.push({
                letter: optionMatch[1],
                text: optionMatch[2]
              });
            }
          }
          
          // Determine difficulty based on content complexity
          let difficulty = 'intermediate';
          if (fullQuestion.includes('LEAST amount of operational overhead') || 
              fullQuestion.includes('most cost-effective') ||
              fullQuestion.includes('Multi-AZ') ||
              fullQuestion.includes('CloudFormation')) {
            difficulty = 'advanced';
          } else if (fullQuestion.length < 200 && options.length <= 2) {
            difficulty = 'beginner';
          }
          
          // Extract tags from question content
          const tags = [];
          const services = ['S3', 'EC2', 'Lambda', 'RDS', 'VPC', 'CloudFront', 'Route53', 'ELB', 'Auto Scaling', 'IAM', 'SQS', 'SNS', 'Aurora', 'Athena'];
          services.forEach(service => {
            if (fullQuestion.includes(service) || correctAnswer?.includes(service) || explanation.includes(service)) {
              tags.push(service.toLowerCase());
            }
          });
          
          const question = {
            id: 'aws-saa-c03-' + String(questionNumber).padStart(3, '0'),
            subject: 'cloud-computing',
            examType: 'AWS-SAA-C03',
            questionNumber: questionNumber,
            question: fullQuestion.trim(),
            options: options,
            correctAnswer: correctAnswer,
            correctAnswerLetter: answerLetter,
            explanation: explanation.trim() || correctAnswer || 'No explanation provided',
            tags: tags,
            difficulty: difficulty,
            lastUpdated: new Date().toISOString()
          };
          
          if (question.question && question.question.length > 50) {
            questions.push(question);
          }
        });
        
        console.log('‚úÖ Parsed', questions.length, 'questions');
        console.log('üìä Questions with options:', questions.filter(q => q.options.length > 0).length);
        console.log('üìä Questions with correct answers:', questions.filter(q => q.correctAnswer).length);
        
        // Save questions
        const questionsFile = path.join(saac03Dir, 'questions.json');
        fs.writeFileSync(questionsFile, JSON.stringify(questions, null, 2));
        
        // Create index
        const index = {
          examCode: 'AWS-SAA-C03',
          examName: 'AWS Certified Solutions Architect - Associate',
          lastUpdated: new Date().toISOString(),
          totalQuestions: questions.length,
          source: {
            repository: 'External AWS SAA-C03 Question Bank',
            sourceType: 'curated-exam-questions',
            lastSync: new Date().toISOString(),
            totalLines: content.split('\n').length
          },
          cdn: {
            questionsUrl: 'https://cdn.jsdelivr.net/gh/Shivaprasadr/TestBeforeExam@main/data/subjects/cloud-computing/aws/saa-c03/questions.json',
            indexUrl: 'https://cdn.jsdelivr.net/gh/Shivaprasadr/TestBeforeExam@main/data/subjects/cloud-computing/aws/saa-c03/index.json'
          },
          statistics: {
            questionsProcessed: questions.length,
            questionsWithOptions: questions.filter(q => q.options.length > 0).length,
            questionsWithAnswers: questions.filter(q => q.correctAnswer).length,
            sourceFileSize: content.length,
            processingDate: new Date().toISOString()
          }
        };
        
        fs.writeFileSync(path.join(saac03Dir, 'index.json'), JSON.stringify(index, null, 2));
        console.log('‚úÖ Created index with', questions.length, 'questions');
        console.log('üìä Processing complete!');
        "
        
    - name: Update sync record
      if: steps.check_updates.outputs.needs_update == 'true'
      run: |
        mkdir -p sync-records
        echo "${{ steps.check_updates.outputs.source_commit }}" > sync-records/last-aws-sync.txt
        
    - name: Commit and push changes
      if: steps.check_updates.outputs.needs_update == 'true'
      run: |
        # Clean up temp directory before commit
        rm -rf temp-aws-repo
        
        git config --local user.email "action@github.com"
        git config --local user.name "GitHub Action"
        
        git add -A
        
        # Create descriptive commit message
        COMMIT_MSG="üîÑ Daily AWS SAA-C03 sync - $(date '+%Y-%m-%d')

        - Updated questions from external source
        - Processing timestamp: $(date -u +%Y-%m-%dT%H:%M:%SZ)
        - Questions processed and validated
        - CDN URLs updated for global delivery"
        
        git commit -m "$COMMIT_MSG" || echo "No changes to commit"
        git push